"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printSchema = exports.buildSchema = exports.g = exports.GarphSchema = exports.Type = void 0;
const utils_1 = require("./utils");
const schema_1 = require("./schema");
Object.defineProperty(exports, "buildSchema", { enumerable: true, get: function () { return schema_1.buildSchema; } });
Object.defineProperty(exports, "printSchema", { enumerable: true, get: function () { return schema_1.printSchema; } });
class Type {
    _name;
    _is;
    _inner;
    _output;
    _args;
    _shape;
    typeDef;
    description(text) {
        this.typeDef.description = text;
        return this;
    }
    deprecated(reason) {
        this.typeDef.deprecated = reason;
        return this;
    }
}
exports.Type = Type;
class GType extends Type {
    constructor(name, shape, interfaces, extend) {
        super();
        this.typeDef = {
            name,
            type: 'ObjectType',
            shape,
            interfaces,
            extend
        };
    }
    implements(ref) {
        // This is temporary construct, until we figure out how to properly manage to shared schema
        this.typeDef.interfaces = Array.isArray(ref) ? ref : [ref];
        return new GType(this.typeDef.name, this.typeDef.shape, Array.isArray(ref) ? ref : [ref], this.typeDef.extend);
    }
    extend(ref) {
        // This is temporary construct, until we figure out how to properly manage to shared schema
        this.typeDef.extend = Array.isArray(ref) ? ref : [ref];
        return new GType(this.typeDef.name, this.typeDef.shape, this.typeDef.interfaces, Array.isArray(ref) ? ref : [ref]);
    }
}
class GInput extends Type {
    constructor(name, shape, extend) {
        super();
        this.typeDef = {
            name,
            type: 'InputType',
            shape,
            extend
        };
    }
    extend(ref) {
        // This is temporary construct, until we figure out how to properly manage to shared schema
        this.typeDef.extend = Array.isArray(ref) ? ref : [ref];
        return new GInput(this.typeDef.name, this.typeDef.shape, Array.isArray(ref) ? ref : [ref]);
    }
}
class GInterface extends Type {
    constructor(name, shape, interfaces, extend) {
        super();
        this.typeDef = {
            name,
            type: 'InterfaceType',
            shape,
            interfaces,
            extend
        };
    }
    implements(ref) {
        // This is temporary construct, until we figure out how to properly manage to shared schema
        this.typeDef.interfaces = Array.isArray(ref) ? ref : [ref];
        return new GInterface(this.typeDef.name, this.typeDef.shape, Array.isArray(ref) ? ref : [ref], this.typeDef.extend);
    }
    extend(ref) {
        // This is temporary construct, until we figure out how to properly manage to shared schema
        this.typeDef.extend = Array.isArray(ref) ? ref : [ref];
        return new GInterface(this.typeDef.name, this.typeDef.shape, this.typeDef.interfaces, Array.isArray(ref) ? ref : [ref]);
    }
}
class GString extends Type {
    constructor(type = 'String') {
        super();
        this.typeDef = {
            type
        };
    }
    optional() {
        return new GOptional(this);
    }
    required() {
        this.typeDef.isRequired = true;
        return this;
    }
    list() {
        return new GList(this);
    }
    default(value) {
        this.typeDef.defaultValue = value;
        return this;
    }
    omitResolver() {
        return new GOmitResolver(this);
    }
    args(args) {
        return new GArgs(this, args);
    }
}
class GNumber extends Type {
    constructor(type = 'Int') {
        super();
        this.typeDef = {
            type
        };
    }
    optional() {
        return new GOptional(this);
    }
    required() {
        this.typeDef.isRequired = true;
        return this;
    }
    list() {
        return new GList(this);
    }
    default(value) {
        this.typeDef.defaultValue = value;
        return this;
    }
    omitResolver() {
        return new GOmitResolver(this);
    }
    args(args) {
        return new GArgs(this, args);
    }
}
class GBoolean extends Type {
    constructor() {
        super();
        this.typeDef = {
            type: 'Boolean'
        };
    }
    optional() {
        return new GOptional(this);
    }
    required() {
        this.typeDef.isRequired = true;
        return this;
    }
    list() {
        return new GList(this);
    }
    default(value) {
        this.typeDef.defaultValue = value;
        return this;
    }
    omitResolver() {
        return new GOmitResolver(this);
    }
    args(args) {
        return new GArgs(this, args);
    }
}
class GEnum extends Type {
    constructor(name, shape) {
        super();
        let enumShape;
        if (Array.isArray(shape)) {
            enumShape = shape;
        }
        else {
            enumShape = (0, utils_1.getEnumProperties)(shape);
        }
        this.typeDef = {
            name,
            type: 'Enum',
            shape: enumShape
        };
    }
}
class GUnion extends Type {
    constructor(name, shape) {
        super();
        this.typeDef = {
            name,
            type: 'Union',
            shape
        };
    }
}
class GRef extends Type {
    constructor(ref) {
        super();
        this.typeDef = {
            shape: ref,
            type: 'Ref'
        };
    }
    optional() {
        return new GOptional(this);
    }
    required() {
        this.typeDef.isRequired = true;
        return this;
    }
    list() {
        return new GList(this);
    }
    paginatedList() {
        return new GPaginatedList(this);
    }
    default(value) {
        this.typeDef.defaultValue = value;
        return this;
    }
    omitResolver() {
        return new GOmitResolver(this);
    }
    args(x) {
        return new GArgs(this, x);
    }
}
class GScalar extends Type {
    constructor(name, scalarOptions) {
        super();
        this.typeDef = {
            name,
            type: 'Scalar',
            scalarOptions
        };
    }
    specifiedByUrl(url) {
        this.typeDef.scalarOptions.specifiedByUrl = url;
        return this;
    }
}
class GList extends Type {
    constructor(shape) {
        super();
        this.typeDef = {
            type: 'List',
            shape: shape
        };
    }
    optional() {
        return new GOptional(this);
    }
    required() {
        this.typeDef.isRequired = true;
        return this;
    }
    default(value) {
        this.typeDef.defaultValue = value;
        return this;
    }
    omitResolver() {
        return new GOmitResolver(this);
    }
    args(args) {
        return new GArgs(this, args);
    }
    list() {
        return new GList(this);
    }
}
class GPaginatedList extends Type {
    constructor(shape) {
        super();
        this.typeDef = {
            type: 'PaginatedList',
            shape: shape
        };
    }
    optional() {
        return new GOptional(this);
    }
    required() {
        this.typeDef.isRequired = true;
        return this;
    }
    omitResolver() {
        return new GOmitResolver(this);
    }
    args(args) {
        return new GArgs(this, args);
    }
}
class GOptional extends Type {
    constructor(shape) {
        super();
        this.typeDef = shape.typeDef;
        this.typeDef.isOptional = true;
        this.typeDef.isRequired = false;
    }
    list() {
        return new GList(this);
    }
    default(value) {
        this.typeDef.defaultValue = value;
        return this;
    }
    omitResolver() {
        return new GOmitResolver(this);
    }
    args(args) {
        return new GArgs(this, args);
    }
}
class GOmitResolver extends Type {
    constructor(shape) {
        super();
        this.typeDef = shape.typeDef;
    }
    optional() {
        return new GOptional(this);
    }
    required() {
        this.typeDef.isRequired = true;
        return this;
    }
    default(value) {
        this.typeDef.defaultValue = value;
        return this;
    }
    args(args) {
        return new GArgs(this, args);
    }
    list() {
        return new GList(this);
    }
}
class GArgs extends Type {
    constructor(shape, args) {
        super();
        this.typeDef = shape.typeDef;
        this.typeDef.args = args;
    }
}
class GarphSchema {
    types = new Map();
    nodeType = this.interface('Node', {
        id: this.id()
    });
    pageInfoType = this.type('PageInfo', {
        hasNextPage: this.boolean(),
        hasPreviousPage: this.boolean(),
        startCursor: this.string().optional(),
        endCursor: this.string().optional()
    });
    pageInfoArgs = {
        first: this.int().optional(),
        last: this.int().optional(),
        before: this.id().optional(),
        after: this.id().optional()
    };
    registerType(type) {
        const name = type.typeDef.name;
        if (!['Node', 'PageInfo'].includes(name) && this.types.has(name))
            throw new Error(`Type with name "${name}" already exists`);
        this.types.set(name, type);
    }
    constructor({ types } = { types: [] }) {
        types.forEach(t => this.registerType(t));
    }
    type(name, shape) {
        const t = new GType(name, shape);
        this.registerType(t);
        return t;
    }
    node(name, shape) {
        const t = new GType(name, shape).implements(this.nodeType);
        this.registerType(t);
        return t;
    }
    connection(name, shape) {
        const t = new GType(name, {
            edges: new GList(shape),
            pageInfo: this.pageInfoType
        });
        this.registerType(t);
        return t;
    }
    edge(name, shape) {
        const t = new GType(name, {
            node: shape,
            cursor: exports.g.string()
        });
        this.registerType(t);
        return t;
    }
    inputType(name, shape) {
        const t = new GInput(name, shape);
        this.registerType(t);
        return t;
    }
    enumType(name, args) {
        const t = new GEnum(name, args);
        this.registerType(t);
        return t;
    }
    unionType(name, args) {
        const t = new GUnion(name, args);
        this.registerType(t);
        return t;
    }
    scalarType(name, options) {
        const t = new GScalar(name, options);
        this.registerType(t);
        return t;
    }
    interface(name, shape) {
        const t = new GInterface(name, shape);
        this.registerType(t);
        return t;
    }
    string() {
        return new GString();
    }
    id() {
        return new GString('ID');
    }
    int() {
        return new GNumber('Int');
    }
    float() {
        return new GNumber('Float');
    }
    boolean() {
        return new GBoolean();
    }
    // The generic has to be any, because constraints cannot be applied to recursive types
    // This is a limitation of TypeScript
    ref(ref) {
        return new GRef(ref);
    }
}
exports.GarphSchema = GarphSchema;
exports.g = new GarphSchema();
