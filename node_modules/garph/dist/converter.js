"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseArgs = exports.parseFields = exports.convertToGraphqlType = exports.getFieldType = exports.convertSchema = void 0;
const graphql_compose_1 = require("graphql-compose");
function convertSchema({ types, resolvers }, config = { defaultNullability: false }) {
    types.forEach(type => graphql_compose_1.schemaComposer.add(convertToGraphqlType(type.typeDef.name, type, config)));
    graphql_compose_1.schemaComposer.addResolveMethods(resolvers);
    return graphql_compose_1.schemaComposer.buildSchema();
}
exports.convertSchema = convertSchema;
function isOptional(target, type, config) {
    return type.typeDef.isRequired ? `${target}!` : type.typeDef.isOptional ? `${target}` : config.defaultNullability ? `${target}` : `${target}!`;
}
function getFieldType(type, config) {
    switch (type.typeDef.type) {
        case 'String':
            return isOptional('String', type, config);
        case 'Int':
            return isOptional('Int', type, config);
        case 'Float':
            return isOptional('Float', type, config);
        case 'Boolean':
            return isOptional('Boolean', type, config);
        case 'ID':
            return isOptional('ID', type, config);
        case 'List':
            return isOptional(`[${getFieldType(type.typeDef.shape, config)}]`, type, config);
        default:
            return isOptional(type.typeDef.name, type, config);
    }
}
exports.getFieldType = getFieldType;
function convertToGraphqlType(name, type, config) {
    switch (type.typeDef.type) {
        case 'ObjectType':
            const objType = graphql_compose_1.schemaComposer.createObjectTC({
                name,
                description: type.typeDef.description,
                fields: parseFields(type.typeDef.shape, config)
            });
            if (type.typeDef.interfaces) {
                type.typeDef.interfaces.forEach(i => {
                    objType.addFields(parseFields(i.typeDef.shape, config));
                    objType.addInterface(i.typeDef.name);
                });
            }
            return objType;
        case 'Enum':
            return graphql_compose_1.schemaComposer.createEnumTC({
                name,
                description: type.typeDef.description,
                values: type.typeDef.shape.reduce((acc, val) => {
                    acc[val] = {};
                    return acc;
                }, {})
            });
        case 'Union':
            return graphql_compose_1.schemaComposer.createUnionTC({
                name,
                description: type.typeDef.description,
                types: type.typeDef.shape.map(t => t.typeDef.name)
            });
        case 'InputType':
            return graphql_compose_1.schemaComposer.createInputTC({
                name,
                description: type.typeDef.description,
                fields: parseFields(type.typeDef.shape, config),
            });
        case 'Scalar':
            return graphql_compose_1.schemaComposer.createScalarTC({
                name,
                description: type.typeDef.description,
                serialize: type.typeDef.scalarOptions.serialize,
                parseValue: type.typeDef.scalarOptions.parseValue,
                parseLiteral: type.typeDef.scalarOptions.parseLiteral,
                specifiedByURL: type.typeDef.scalarOptions.specifiedByUrl
            });
        case 'InterfaceType':
            const interfaceType = graphql_compose_1.schemaComposer.createInterfaceTC({
                name,
                description: type.typeDef.description,
                fields: parseFields(type.typeDef.shape, config)
            });
            if (type.typeDef.interfaces) {
                type.typeDef.interfaces.forEach(i => {
                    interfaceType.addFields(parseFields(i.typeDef.shape, config));
                    interfaceType.addInterface(i.typeDef.name);
                });
            }
            return interfaceType;
    }
}
exports.convertToGraphqlType = convertToGraphqlType;
function parseFields(fields, config) {
    const fieldsObj = {};
    Object.keys(fields).forEach(fieldName => {
        const field = fields[fieldName];
        fieldsObj[fieldName] = {
            type: getFieldType(field, config),
            deprecationReason: field.typeDef.deprecated,
            args: parseArgs(field.typeDef.args, config),
            description: field.typeDef.description
        };
    });
    return fieldsObj;
}
exports.parseFields = parseFields;
function parseArgs(anyArgs, config) {
    if (!anyArgs)
        return;
    const args = {};
    Object.keys(anyArgs).forEach(argName => {
        const arg = anyArgs[argName];
        args[argName] = {
            type: getFieldType(arg, config),
            defaultValue: arg.typeDef.defaultValue,
            deprecationReason: arg.typeDef.deprecated,
            description: arg.typeDef.description
        };
    });
    return args;
}
exports.parseArgs = parseArgs;
