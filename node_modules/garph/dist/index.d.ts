import type { GraphQLResolveInfo } from 'graphql';
import { TSEnumType, UnionToIntersection, ObjectToUnion, ExpandRecursively, MaybePromise, MaybeFunction } from './utils';
import { buildSchema, printSchema } from './schema';
type GraphQLRootType = 'Query' | 'Mutation' | 'Subscription';
type GarphType = 'String' | 'Int' | 'Float' | 'Boolean' | 'ID' | 'ObjectType' | 'InterfaceType' | 'InputType' | 'Scalar' | 'Enum' | 'List' | 'PaginatedList' | 'Union' | 'Ref' | 'Optional' | 'Args' | 'OmitResolver';
export declare abstract class Type<T, X extends GarphType> {
    _name?: string;
    _is: X;
    _inner?: any;
    _output?: any;
    _args?: Args;
    _shape: T;
    typeDef: TypeDefinition<T>;
    description(text: string): this;
    deprecated(reason: string): this;
}
export type TypeDefinition<T> = {
    name?: string;
    type: GarphType;
    shape?: T;
    args?: Args;
    description?: string;
    isOptional?: boolean;
    isRequired?: boolean;
    deprecated?: string;
    scalarOptions?: ScalarOptions<any, any>;
    defaultValue?: any;
    interfaces?: AnyInterface[];
    extend?: AnyTypes[];
};
export type AnyType = Type<any, any>;
export type AnyString = Type<string, 'String'>;
export type AnyID = Type<string, 'ID'>;
export type AnyBoolean = Type<boolean, 'Boolean'>;
export type AnyNumber = Type<number, any>;
export type AnyInt = Type<number, 'Int'>;
export type AnyFloat = Type<number, 'Float'>;
export type AnyRef = Type<any, 'Ref'>;
export type AnyList = Type<any, 'List'>;
export type AnyPaginatedList = Type<any, 'PaginatedList'>;
export type AnyUnion = Type<any, 'Union'>;
export type AnyEnum = Type<any, 'Enum'>;
export type AnyScalar = Type<any, 'Scalar'>;
export type AnyInput = Type<any, 'InputType'>;
export type AnyInterface = Type<any, 'InterfaceType'>;
export type AnyArgs = Type<any, 'Args'>;
export type AnyOptional = Type<any, 'Optional'>;
export type AnyObject = Type<any, 'ObjectType'>;
export type AnyOmitResolver = Type<any, 'OmitResolver'>;
export type Args = {
    [key: string]: AnyType;
};
export type AnyTypes = {
    [key: string]: AnyType;
};
export type AnyObjects = {
    [key: string]: AnyObject;
};
type ScalarOptions<I, O> = {
    serialize: (value: I) => O;
    parseValue: (value: O) => I;
    parseLiteral?: (ast: any) => I;
    specifiedByUrl?: string;
};
type InferResolverConfig = {
    context?: any;
};
type InferOptions = {
    omitResolver?: AnyOmitResolver | never;
};
type RefType = () => AnyType;
export type Infer<T, options extends InferOptions = {
    omitResolver: never;
}> = ExpandRecursively<InferRaw<T, options>>;
export type InferRaw<T, options extends InferOptions = {
    omitResolver: never;
}> = T extends AnyInput | AnyObject | AnyInterface ? {
    __typename?: T['_name'];
} & {
    [K in keyof T['_shape'] as T['_shape'][K] extends AnyOptional | options['omitResolver'] ? never : T['_shape'][K] extends AnyArgs ? T['_shape'][K]['_shape'] extends AnyOptional | options['omitResolver'] ? never : K : K]: InferRaw<T['_shape'][K], options>;
} & {
    [K in keyof T['_shape'] as T['_shape'][K] extends AnyOptional | options['omitResolver'] ? K : T['_shape'][K] extends AnyArgs ? T['_shape'][K]['_shape'] extends AnyOptional | options['omitResolver'] ? K : never : never]?: InferRaw<T['_shape'][K], options>;
} : InferShallow<T, options>;
export type InferShallow<T, options extends InferOptions = {
    omitResolver: never;
}> = T extends AnyString | AnyID | AnyScalar | AnyNumber | AnyBoolean ? T['_shape'] : T extends AnyEnum ? T['_inner'] : T extends AnyUnion ? InferRaw<ObjectToUnion<T['_inner']>, options> : T extends AnyList ? InferRaw<T['_shape'], options>[] : T extends AnyPaginatedList ? T['_inner'] : T extends AnyOptional ? InferRaw<T['_shape'], options> | null | undefined : T extends AnyOmitResolver ? InferRaw<T['_shape'], options> : T extends AnyArgs ? InferRaw<T['_shape'], options> : T extends AnyRef ? InferRaw<T['_inner'], options> : T;
export type InferArgs<T extends AnyType> = ExpandRecursively<InferArgsRaw<T>>;
export type InferArgsRaw<T extends AnyType> = T extends AnyObject | AnyInterface ? {
    [K in keyof T['_shape']]: InferArgRaw<T['_shape'][K]>;
} : never;
export type InferArg<T> = ExpandRecursively<InferArgRaw<T>>;
export type InferArgRaw<T> = T extends AnyArgs ? {
    [K in keyof T['_args'] as T['_args'][K] extends AnyOptional ? never : K]: InferRaw<T['_args'][K]>;
} & {
    [K in keyof T['_args'] as T['_args'][K] extends AnyOptional ? K : never]?: InferRaw<T['_args'][K]>;
} : never;
export type InferUnionNames<T> = T extends AnyUnion ? ObjectToUnion<T['_inner']>['_name'] : never;
export type InferResolvers<T extends AnyTypes, X extends InferResolverConfig> = {
    [K in keyof T]: K extends 'Subscription' ? {
        [G in keyof T[K]['_shape']]?: {
            subscribe: (parent: {}, args: InferArg<T[K]['_shape'][G]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<AsyncIterator<{
                [S in G]: Infer<T[K]['_shape'][G], {
                    omitResolver: AnyOmitResolver;
                }>;
            }>>;
            resolve?: (value: Infer<T[K]['_shape'][G]>, args: InferArg<T[K]['_shape'][G]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<Infer<T[K]['_shape'][G], {
                omitResolver: AnyOmitResolver;
            }>>;
        };
    } : {
        [G in keyof T[K]['_shape']]?: (parent: K extends GraphQLRootType ? {} : Infer<T[K]>, args: InferArg<T[K]['_shape'][G]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<MaybeFunction<Infer<T[K]['_shape'][G], {
            omitResolver: AnyOmitResolver;
        }>>> | AsyncGenerator<Infer<T[K]['_shape'][G]['_shape'], {
            omitResolver: AnyOmitResolver;
        }>>;
    } | ({
        [G in keyof T[K]['_shape']]?: {
            resolve: (parent: K extends GraphQLRootType ? {} : Infer<T[K]>, args: InferArg<T[K]['_shape'][G]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<Infer<T[K]['_shape'][G], {
                omitResolver: AnyOmitResolver;
            }>> | AsyncGenerator<Infer<T[K]['_shape'][G]['_shape'], {
                omitResolver: AnyOmitResolver;
            }>>;
        } | {
            load: (queries: {
                parent: K extends GraphQLRootType ? {} : Infer<T[K]>;
                args: InferArg<T[K]['_shape'][G]>;
                context: X['context'];
                info: GraphQLResolveInfo;
            }[]) => MaybePromise<Infer<T[K]['_shape'][G], {
                omitResolver: AnyOmitResolver;
            }>[]>;
        } | {
            loadBatch: (queries: {
                parent: K extends GraphQLRootType ? {} : Infer<T[K]>;
                args: InferArg<T[K]['_shape'][G]>;
                context: X['context'];
                info: GraphQLResolveInfo;
            }[]) => MaybePromise<Infer<T[K]['_shape'][G], {
                omitResolver: AnyOmitResolver;
            }>[]>;
        };
    } & {
        __isTypeOf?: (parent: Infer<T[K]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<boolean>;
        __resolveType?: (parent: Infer<T[K]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<InferUnionNames<T[K]>>;
    });
};
export type InferResolversStrict<T extends AnyTypes, X extends InferResolverConfig> = {
    [K in keyof T]: K extends 'Subscription' ? {
        [G in keyof T[K]['_shape']]: {
            subscribe: (parent: {}, args: InferArg<T[K]['_shape'][G]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<AsyncIterator<{
                [S in G]: Infer<T[K]['_shape'][G], {
                    omitResolver: AnyOmitResolver;
                }>;
            }>>;
            resolve?: (value: Infer<T[K]['_shape'][G]>, args: InferArg<T[K]['_shape'][G]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<Infer<T[K]['_shape'][G], {
                omitResolver: AnyOmitResolver;
            }>>;
        };
    } : {
        [G in keyof T[K]['_shape']]: (parent: K extends GraphQLRootType ? {} : Infer<T[K]>, args: InferArg<T[K]['_shape'][G]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<MaybeFunction<Infer<T[K]['_shape'][G], {
            omitResolver: AnyOmitResolver;
        }>>> | AsyncGenerator<Infer<T[K]['_shape'][G]['_shape'], {
            omitResolver: AnyOmitResolver;
        }>>;
    } | ({
        [G in keyof T[K]['_shape']]: {
            resolve: (parent: K extends GraphQLRootType ? {} : Infer<T[K]>, args: InferArg<T[K]['_shape'][G]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<Infer<T[K]['_shape'][G], {
                omitResolver: AnyOmitResolver;
            }>> | AsyncGenerator<Infer<T[K]['_shape'][G]['_shape'], {
                omitResolver: AnyOmitResolver;
            }>>;
        } | {
            load: (queries: {
                parent: K extends GraphQLRootType ? {} : Infer<T[K]>;
                args: InferArg<T[K]['_shape'][G]>;
                context: X['context'];
                info: GraphQLResolveInfo;
            }[]) => MaybePromise<Infer<T[K]['_shape'][G], {
                omitResolver: AnyOmitResolver;
            }>>[];
        } | {
            loadBatch: (queries: {
                parent: K extends GraphQLRootType ? {} : Infer<T[K]>;
                args: InferArg<T[K]['_shape'][G]>;
                context: X['context'];
                info: GraphQLResolveInfo;
            }[]) => MaybePromise<Infer<T[K]['_shape'][G], {
                omitResolver: AnyOmitResolver;
            }>>[];
        };
    } & {
        __isTypeOf?: (parent: Infer<T[K]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<boolean>;
        __resolveType?: (parent: Infer<T[K]>, context: X['context'], info: GraphQLResolveInfo) => MaybePromise<InferUnionNames<T[K]>>;
    });
};
declare class GType<N extends string, T extends AnyTypes> extends Type<T, 'ObjectType'> {
    _name: N;
    constructor(name: string, shape: T, interfaces?: AnyInterface[], extend?: AnyTypes[]);
    implements<D extends AnyInterface>(ref: D | D[]): GType<N, T & UnionToIntersection<D["_shape"]>>;
    extend<D extends AnyTypes>(ref: D | D[]): GType<N, T & UnionToIntersection<D>>;
}
declare class GInput<N extends string, T extends AnyTypes> extends Type<T, 'InputType'> {
    _name: N;
    constructor(name: string, shape: T, extend?: AnyTypes[]);
    extend<D extends AnyTypes>(ref: D | D[]): GInput<N, T & UnionToIntersection<D>>;
}
declare class GInterface<N extends string, T extends AnyTypes> extends Type<T, 'InterfaceType'> {
    _name: N;
    constructor(name: string, shape: T, interfaces?: AnyInterface[], extend?: AnyTypes[]);
    implements<D extends AnyInterface>(ref: D | D[]): GInterface<N, T & UnionToIntersection<D["_shape"]>>;
    extend<D extends AnyTypes>(ref: D | D[]): GInterface<N, T & UnionToIntersection<D>>;
}
declare class GString<T extends GarphType> extends Type<string, T> {
    constructor(type?: 'String' | 'ID');
    optional(): GOptional<this>;
    required(): this;
    list(): GList<this>;
    default(value: string): this;
    omitResolver(): GOmitResolver<this>;
    args<X extends Args>(args: X): GArgs<this, X>;
}
declare class GNumber<T extends GarphType> extends Type<number, T> {
    constructor(type?: 'Int' | 'Float');
    optional(): GOptional<this>;
    required(): this;
    list(): GList<this>;
    default(value: number): this;
    omitResolver(): GOmitResolver<this>;
    args<X extends Args>(args: X): GArgs<this, X>;
}
declare class GBoolean extends Type<boolean, 'Boolean'> {
    constructor();
    optional(): GOptional<this>;
    required(): this;
    list(): GList<this>;
    default(value: boolean): this;
    omitResolver(): GOmitResolver<this>;
    args<X extends Args>(args: X): GArgs<this, X>;
}
declare class GEnum<N extends string, T extends readonly string[] | TSEnumType> extends Type<readonly string[], 'Enum'> {
    _name: N;
    _inner: T extends readonly string[] ? T[number] : keyof T;
    constructor(name: string, shape: T);
}
declare class GUnion<N extends string, T extends AnyObjects> extends Type<T, 'Union'> {
    _name: N;
    _inner: T;
    constructor(name: string, shape: T);
}
declare class GRef<T> extends Type<T, 'Ref'> {
    _inner: T extends RefType ? ReturnType<T> : T;
    constructor(ref: T);
    optional(): GOptional<this>;
    required(): this;
    list(): GList<this>;
    paginatedList(): GPaginatedList<this>;
    default(value: InferRaw<this['_inner']>): this;
    omitResolver(): GOmitResolver<this>;
    args<X extends Args>(x: X): GArgs<this, X>;
}
declare class GScalar<I, O> extends Type<I, 'Scalar'> {
    _output: O;
    constructor(name: string, scalarOptions?: ScalarOptions<I, O>);
    specifiedByUrl(url: string): this;
}
declare class GList<T extends AnyType> extends Type<T, 'List'> {
    constructor(shape: T);
    optional(): GOptional<this>;
    required(): this;
    default(value: typeof this._inner): this;
    omitResolver(): GOmitResolver<this>;
    args<X extends Args>(args: X): GArgs<this, X>;
    list(): GList<this>;
}
declare class GPaginatedList<T extends AnyType> extends Type<T, 'PaginatedList'> {
    _inner: {
        edges: {
            node: InferRaw<T>;
            cursor: string;
        }[];
        pageInfo: {
            hasNextPage: boolean;
            hasPreviousPage: boolean;
            startCursor?: string;
            endCursor?: string;
        };
    };
    constructor(shape: T);
    optional(): GOptional<this>;
    required(): this;
    omitResolver(): GOmitResolver<this>;
    args<X extends Args>(args: X): GArgs<this, X>;
}
declare class GOptional<T extends AnyType> extends Type<T, 'Optional'> {
    constructor(shape: T);
    list(): GList<this>;
    default(value: InferRaw<T>): this;
    omitResolver(): GOmitResolver<this>;
    args<X extends Args>(args: X): GArgs<this, X>;
}
declare class GOmitResolver<T extends AnyType> extends Type<T, 'OmitResolver'> {
    constructor(shape: T);
    optional(): GOptional<this>;
    required(): this;
    default(value: InferRaw<T>): this;
    args<X extends Args>(args: X): GArgs<this, X>;
    list(): GList<this>;
}
declare class GArgs<T extends AnyType, X extends Args> extends Type<T, 'Args'> {
    _args: X;
    constructor(shape: T, args: X);
}
export declare class GarphSchema {
    types: Map<string, AnyType>;
    nodeType: GInterface<"Node", {
        id: GString<"ID">;
    }>;
    pageInfoType: GType<"PageInfo", {
        hasNextPage: GBoolean;
        hasPreviousPage: GBoolean;
        startCursor: GOptional<GString<"String">>;
        endCursor: GOptional<GString<"String">>;
    }>;
    pageInfoArgs: {
        first: GOptional<GNumber<"Int">>;
        last: GOptional<GNumber<"Int">>;
        before: GOptional<GString<"ID">>;
        after: GOptional<GString<"ID">>;
    };
    registerType(type: AnyType): void;
    constructor({ types }?: {
        types: AnyType[];
    });
    type<N extends string, T extends AnyTypes>(name: N, shape: T): GType<N, T>;
    node<N extends string, T extends AnyTypes>(name: N, shape: T): GType<N, T & {
        id: GString<"ID">;
    }>;
    connection<N extends string, T extends AnyRef>(name: N, shape: T): GType<string, {
        edges: GList<T>;
        pageInfo: GType<"PageInfo", {
            hasNextPage: GBoolean;
            hasPreviousPage: GBoolean;
            startCursor: GOptional<GString<"String">>;
            endCursor: GOptional<GString<"String">>;
        }>;
    }>;
    edge<N extends string, T extends AnyRef>(name: N, shape: T): GType<N, {
        node: T;
        cursor: AnyString;
    }>;
    inputType<N extends string, T extends AnyTypes>(name: N, shape: T): GInput<N, T>;
    enumType<N extends string, T extends readonly string[] | TSEnumType>(name: N, args: T): GEnum<N, T>;
    unionType<N extends string, T extends AnyObjects>(name: N, args: T): GUnion<N, T>;
    scalarType<I, O>(name: string, options?: ScalarOptions<I, O>): GScalar<I, O>;
    interface<N extends string, T extends AnyTypes>(name: N, shape: T): GInterface<N, T>;
    string(): GString<"String">;
    id(): GString<"ID">;
    int(): GNumber<"Int">;
    float(): GNumber<"Float">;
    boolean(): GBoolean;
    ref<T>(ref: T): GRef<T>;
}
export declare const g: GarphSchema;
export { buildSchema, printSchema };
